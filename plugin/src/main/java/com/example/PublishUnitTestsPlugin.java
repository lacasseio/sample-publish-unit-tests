/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package com.example;

import org.gradle.api.Action;
import org.gradle.api.NamedDomainObjectProvider;
import org.gradle.api.Plugin;
import org.gradle.api.Project;
import org.gradle.api.Task;
import org.gradle.api.artifacts.Configuration;
import org.gradle.api.artifacts.DependencySet;
import org.gradle.api.attributes.Attribute;
import org.gradle.api.attributes.Usage;
import org.gradle.api.component.AdhocComponentWithVariants;
import org.gradle.api.component.SoftwareComponent;
import org.gradle.api.component.SoftwareComponentFactory;
import org.gradle.api.plugins.ExtensionAware;
import org.gradle.api.plugins.ExtraPropertiesExtension;
import org.gradle.api.provider.Provider;
import org.gradle.api.publish.PublicationContainer;
import org.gradle.api.publish.PublishingExtension;
import org.gradle.api.publish.maven.MavenPublication;
import org.gradle.api.publish.maven.tasks.PublishToMavenRepository;
import org.gradle.api.publish.tasks.GenerateModuleMetadata;
import org.gradle.language.cpp.CppBinary;
import org.gradle.nativeplatform.MachineArchitecture;
import org.gradle.nativeplatform.OperatingSystemFamily;
import org.gradle.nativeplatform.TargetMachine;
import org.gradle.nativeplatform.test.cpp.CppTestExecutable;
import org.gradle.nativeplatform.test.cpp.CppTestSuite;

import javax.annotation.Nullable;
import javax.inject.Inject;
import java.io.IOException;
import java.io.UncheckedIOException;
import java.nio.file.Files;
import java.util.Collections;
import java.util.Iterator;
import java.util.concurrent.Callable;
import java.util.function.Supplier;

import static java.nio.charset.StandardCharsets.UTF_8;
import static java.util.Objects.requireNonNull;

/**
 * A simple 'hello world' plugin.
 */
public abstract class PublishUnitTestsPlugin implements Plugin<Project> {
    private static final Attribute<String> TEST_SUITE_NAME_ATTRIBUTE = Attribute.of("com.example.testsuite.name", String.class);
    private static final Attribute<String> TEST_SUITE_TYPE_ATTRIBUTE = Attribute.of("com.example.testsuite.type", String.class);
    private static final String UNIT_TEST = "unit-test";

    private static Action<CppTestExecutable> registerTestExecutableRuntimeElements(Project project, CppTestSuite unitTest) {
        return binary -> {
            project.getConfigurations().create(qualifyingName(binary) + "RuntimeElements", new Action<>() {
                @Override
                public void execute(Configuration configuration) {
                    configuration.setCanBeResolved(false);
                    configuration.setCanBeConsumed(true);
                    configuration.setDescription(String.format("Runtime elements for C++ test executable '%s'", qualifyingName(binary)));
                    configuration.attributes(attributes -> {
                        attributes.attribute(Usage.USAGE_ATTRIBUTE, project.getObjects().named(Usage.class, Usage.NATIVE_RUNTIME));
                        attributes.attribute(MachineArchitecture.ARCHITECTURE_ATTRIBUTE, binary.getTargetMachine().getArchitecture());
                        attributes.attribute(OperatingSystemFamily.OPERATING_SYSTEM_ATTRIBUTE, binary.getTargetMachine().getOperatingSystemFamily());
                        attributes.attributeProvider(CppBinary.DEBUGGABLE_ATTRIBUTE, providerOf(binary, "debuggable", binary::isDebuggable));
                        attributes.attributeProvider(CppBinary.OPTIMIZED_ATTRIBUTE, providerOf(binary, "optimized", binary::isOptimized));
                        attributes.attribute(TEST_SUITE_NAME_ATTRIBUTE, unitTest.getName());
                        attributes.attribute(TEST_SUITE_TYPE_ATTRIBUTE, UNIT_TEST);
                    });
                    configuration.getOutgoing().artifact(binary.getExecutableFile());
                }

                private <T> Provider<T> providerOf(Object thiz, String extName, Supplier<T> defaultValue) {
                    return project.provider(() -> {
                        if (thiz instanceof ExtensionAware) {
                            ExtraPropertiesExtension ext = ((ExtensionAware) thiz).getExtensions().getExtraProperties();
                            if (ext.has(extName)) {
                                @SuppressWarnings("unchecked")
                                T result = (T) ext.get(extName);
                                return result;
                            } else {
                                return null;
                            }
                        } else {
                            return null;
                        }
                    }).orElse(project.provider(defaultValue::get));
                }
            });
        };
    }

    // Round about way to do `MavenPublicationInternal#publishWithOriginalFileName()`
    private static Action<MavenPublication> publishWithOriginalFileName(Project project) {
        return publication -> {
            project.getTasks().configureEach(new Action<Task>() {
                @Override
                public void execute(Task task) {
                    if (task.getName().equals(String.format("generateMetadataFileFor%sPublication", capitalize(publication.getName())))) {
                        // !!! Must use anonymous class !!!
                        task.doLast(forTaskType(new Action<GenerateModuleMetadata>() {
                            @Override
                            public void execute(GenerateModuleMetadata t) {
                                try {
                                    Files.write(t.getOutputFile().getAsFile().get().toPath(), Files.readString(t.getOutputFile().getAsFile().get().toPath(), UTF_8).replace("\"name\": \"" + publication.getArtifactId() + "-" + publication.getVersion() + "\"", "\"name\": \"" + one(publication.getArtifacts()).getFile().getName() + "\"").getBytes(UTF_8));
                                } catch (IOException e) {
                                    throw new UncheckedIOException(e);
                                }
                            }

                            private <T> T one(Iterable<T> items) {
                                final Iterator<T> iter = items.iterator();
                                assert iter.hasNext();
                                T result = iter.next();
                                assert !iter.hasNext();
                                return result;
                            }
                        }));
                    }
                }

                @SuppressWarnings("unchecked")
                public <T extends Task> Action<Task> forTaskType(Action<? super T> action) {
                    // !!! Must use anonymous class !!!
                    return new Action<>() {
                        @Override
                        public void execute(Task task) {
                            action.execute((T) task);
                        }
                    };
                }
            });
        };
    }

    private static Action<CppTestExecutable> registerTestExecutablePublication(Project project, CppTestSuite unitTest) {
        return new Action<>() {
            @Override
            public void execute(CppTestExecutable binary) {
                final SoftwareComponent testComponent = newSoftwareComponent(qualifyingName(binary), component -> {
                    // We expect the testExecutableRuntimeElements to already exists
                    final Configuration runtimeElements = project.getConfigurations().getByName(qualifyingName(binary) + "RuntimeElements");
                    component.addVariantsFromConfiguration(runtimeElements, it -> { /* nothing to do */ });
                });

                project.getPluginManager().withPlugin("maven-publish", __ -> {
                    final PublishingExtension publishing = project.getExtensions().getByType(PublishingExtension.class);
                    publishing.publications(publications -> {
                        final NamedDomainObjectProvider<MavenPublication> binaryPublication = publications.register(qualifyingName(binary), MavenPublication.class);
                        binaryPublication.configure(publishWithOriginalFileName(project));
                        binaryPublication.configure(publication -> {
                            publication.from(testComponent); // Use SoftwareComponent to benefit from Gradle's automation

                            // Will override if there is only one binary later
                            publication.setArtifactId(project.getName() + capitalize(unitTest.getName()) + "_" + variantId(binary.getTargetMachine()));
                        });
                    });
                });
            }

            private SoftwareComponent newSoftwareComponent(String name, Action<? super AdhocComponentWithVariants> action) {
                AdhocComponentWithVariants component = project.getObjects().newInstance(SoftwareComponentFactoryProvider.class).get().adhoc(name);
                action.execute(component);
                project.getComponents().add(component);
                return component;
            }
        };
    }

    public void apply(Project project) {
        project.getComponents().withType(CppTestSuite.class).all(unitTest -> {
            // We register the testExecutableRuntimeElements separately from usage because we could separate them both, in theory.
            unitTest.getBinaries().configureEach(CppTestExecutable.class,
                    registerTestExecutableRuntimeElements(project, unitTest));

            unitTest.getBinaries().configureEach(CppTestExecutable.class, registerTestExecutablePublication(project, unitTest));

            project.afterEvaluate(ignored -> {
                project.getPluginManager().withPlugin("maven-publish", __ -> {
                    PublishingExtension publishing = project.getExtensions().getByType(PublishingExtension.class);
                    publishing.publications(new Action<>() {
                        @Override
                        public void execute(PublicationContainer publications) {
                            // When multiple unit tests binary, prepare an aggregate publication
                            if (publications.findByName(unitTest.getName()) == null) {
                                SoftwareComponent testComponent = newSoftwareComponent(unitTest.getName(), component -> {
                                    for (TargetMachine targetMachine : unitTest.getTargetMachines().get()) {
                                        final String name = unitTest.getName() + capitalize(targetMachine.getOperatingSystemFamily().getName()) + capitalize(targetMachine.getArchitecture().getName());
                                        final Configuration runtimeElements = project.getConfigurations().create(unitTest.getName() + capitalize(targetMachine.getOperatingSystemFamily().getName()) + capitalize(targetMachine.getArchitecture().getName()) + "RuntimeElements", configuration -> {
                                            configuration.setDescription(String.format("Runtime elements for publishing C++ test executable '%s'.", name));
                                            configuration.setVisible(false);
                                            project.getTasks().withType(PublishToMavenRepository.class).configureEach(task -> {
                                                if (task.getName().startsWith("publish" + capitalize(unitTest.getName()) + "Publication")) {
                                                    task.dependsOn((Callable<Object>) () -> {
                                                        configuration.setCanBeResolved(false);
                                                        configuration.setCanBeConsumed(true);
                                                        configuration.attributes(attributes -> {
                                                            attributes.attribute(Usage.USAGE_ATTRIBUTE, project.getObjects().named(Usage.class, Usage.NATIVE_RUNTIME));
                                                            attributes.attribute(MachineArchitecture.ARCHITECTURE_ATTRIBUTE, targetMachine.getArchitecture());
                                                            attributes.attribute(OperatingSystemFamily.OPERATING_SYSTEM_ATTRIBUTE, targetMachine.getOperatingSystemFamily());
                                                            attributes.attribute(CppBinary.OPTIMIZED_ATTRIBUTE, false);
                                                            attributes.attribute(CppBinary.DEBUGGABLE_ATTRIBUTE, true);
                                                            attributes.attribute(TEST_SUITE_NAME_ATTRIBUTE, unitTest.getName());
                                                            attributes.attribute(TEST_SUITE_TYPE_ATTRIBUTE, UNIT_TEST);
                                                        });
                                                        return Collections.emptyList();
                                                    });
                                                }
                                            });
                                            configuration.defaultDependencies(new Action<>() {
                                                @Override
                                                public void execute(DependencySet it) {
                                                    it.add(project.getDependencies().create(requireNonNull(unpack(project.getGroup())) + ":" + project.getName() + capitalize(unitTest.getName()) + "_" + variantId(targetMachine) + ":" + requireNonNull(unpack(project.getVersion()))));
                                                }

                                                @Nullable
                                                private Object unpack(Object obj) {
                                                    while (obj instanceof Callable || obj instanceof Supplier) {
                                                        if (obj instanceof Callable) {
                                                            obj = uncheckedCall((Callable<?>) obj);
                                                        } else if (obj instanceof Supplier) {
                                                            obj = ((Supplier<?>) obj).get();
                                                        }
                                                    }

                                                    if (obj instanceof Provider) {
                                                        return ((Provider<?>) obj).get();
                                                    }
                                                    return obj;
                                                }

                                                private Object uncheckedCall(Callable<?> callable) {
                                                    try {
                                                        return callable.call();
                                                    } catch (Exception e) {
                                                        throw new RuntimeException(e);
                                                    }
                                                }
                                            });
                                        });
                                        component.addVariantsFromConfiguration(runtimeElements, it -> { /* nothing to do */});
                                    }
                                });

                                publications.create(unitTest.getName(), MavenPublication.class, publication -> {
                                    publication.from(testComponent);
                                });
                            }

                            // Override artifactId for both the single variant or multi-variant
                            publications.named(unitTest.getName(), MavenPublication.class, publication -> {
                                publication.setArtifactId(project.getName() + capitalize(unitTest.getName()));
                            });
                        }

                        private SoftwareComponent newSoftwareComponent(String name, Action<? super AdhocComponentWithVariants> action) {
                            AdhocComponentWithVariants component = project.getObjects().newInstance(SoftwareComponentFactoryProvider.class).get().adhoc(name);
                            action.execute(component);
                            project.getComponents().add(component);
                            return component;
                        }
                    });
                });
            });
        });
    }

    private static String variantId(TargetMachine targetMachine) {
        return targetMachine.getOperatingSystemFamily().getName() + "_" + targetMachine.getArchitecture().getName();
    }

    //region Names
    private static String qualifyingName(CppBinary binary) {
        String result = binary.getName();
        if (result.startsWith("main")) {
            result = result.substring("main".length());
        } else if (result.endsWith("Executable")) {
            result = result.substring(0, result.length() - "Executable".length());
        }
        return uncapitalize(result);
    }
    //endregion

    //region StringUtils
    private static String uncapitalize(String s) {
        return Character.toLowerCase(s.charAt(0)) + s.substring(1);
    }

    private static String capitalize(String s) {
        return Character.toUpperCase(s.charAt(0)) + s.substring(1);
    }
    //endregion

    //region Provider class to avoid reaching into `ServiceRegistry` from `ProjectInternal#getServices()`.
    static abstract class SoftwareComponentFactoryProvider {
        private final SoftwareComponentFactory theService;

        @Inject
        public SoftwareComponentFactoryProvider(SoftwareComponentFactory theService) {
            this.theService = theService;
        }

        public SoftwareComponentFactory get() {
            return theService;
        }
    }
    //endregion
}
