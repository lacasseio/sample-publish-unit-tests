/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package com.example;

import org.gradle.api.Action;
import org.gradle.api.NamedDomainObjectProvider;
import org.gradle.api.Plugin;
import org.gradle.api.Project;
import org.gradle.api.Task;
import org.gradle.api.XmlProvider;
import org.gradle.api.artifacts.Configuration;
import org.gradle.api.attributes.Attribute;
import org.gradle.api.attributes.AttributeContainer;
import org.gradle.api.attributes.Usage;
import org.gradle.api.component.AdhocComponentWithVariants;
import org.gradle.api.component.SoftwareComponent;
import org.gradle.api.component.SoftwareComponentFactory;
import org.gradle.api.publish.PublishingExtension;
import org.gradle.api.publish.maven.MavenPom;
import org.gradle.api.publish.maven.MavenPublication;
import org.gradle.api.publish.tasks.GenerateModuleMetadata;
import org.gradle.api.tasks.TaskProvider;
import org.gradle.language.cpp.CppBinary;
import org.gradle.nativeplatform.MachineArchitecture;
import org.gradle.nativeplatform.OperatingSystemFamily;
import org.gradle.nativeplatform.TargetMachine;
import org.gradle.nativeplatform.test.cpp.CppTestExecutable;
import org.gradle.nativeplatform.test.cpp.CppTestSuite;

import javax.inject.Inject;
import java.io.IOException;
import java.io.UncheckedIOException;
import java.nio.file.Files;
import java.util.Iterator;
import java.util.Objects;

import static java.nio.charset.StandardCharsets.UTF_8;
import static org.gradle.util.internal.DeferredUtil.unpack;

/**
 * A simple 'hello world' plugin.
 */
public abstract class PublishUnitTestsPlugin implements Plugin<Project> {
    private static final Attribute<String> TEST_SUITE_NAME_ATTRIBUTE = Attribute.of("com.example.testsuite.name", String.class);
    private static final Attribute<String> TEST_SUITE_TYPE_ATTRIBUTE = Attribute.of("com.example.testsuite.type", String.class);
    private static final String UNIT_TEST = "unit-test";

    private static Action<CppTestExecutable> registerTestExecutableRuntimeElements(Project project, CppTestSuite unitTest) {
        return binary -> {
            project.getConfigurations().create(qualifyingName(binary) + "RuntimeElements", new Action<>() {
                @Override
                public void execute(Configuration configuration) {
                    configuration.setCanBeResolved(false);
                    configuration.setCanBeConsumed(true);
                    configuration.setDescription(String.format("Runtime elements for C++ test executable '%s'", qualifyingName(binary)));
                    configuration.attributes(copyFromNativeRuntime());
                    configuration.attributes(attributes -> {
                        attributes.attribute(TEST_SUITE_NAME_ATTRIBUTE, unitTest.getName());
                        attributes.attribute(TEST_SUITE_TYPE_ATTRIBUTE, UNIT_TEST);
                    });
                    configuration.getOutgoing().artifact(binary.getExecutableFile());
                }

                @SuppressWarnings({"rawtypes", "unchecked"})
                private Action<AttributeContainer> copyFromNativeRuntime() {
                    return attributes -> {
                        final Configuration nativeRuntime = project.getConfigurations().getByName("nativeRuntime" + capitalize(qualifyingName(binary)));
                        for (Attribute attribute : nativeRuntime.getAttributes().keySet()) {
                            attributes.attribute(attribute, Objects.requireNonNull(nativeRuntime.getAttributes().getAttribute(attribute)));
                        }
                    };
                }
            });
        };
    }

    // Round about way to do `MavenPublicationInternal#publishWithOriginalFileName()`
    private static Action<MavenPublication> publishWithOriginalFileName(Project project) {
        return publication -> {
            project.getTasks().configureEach(new Action<Task>() {
                @Override
                public void execute(Task task) {
                    if (task.getName().equals(String.format("generateMetadataFileFor%sPublication", capitalize(publication.getName())))) {
                        // !!! Must use anonymous class !!!
                        task.doLast(forTaskType(new Action<GenerateModuleMetadata>() {
                            @Override
                            public void execute(GenerateModuleMetadata t) {
                                try {
                                    Files.write(t.getOutputFile().getAsFile().get().toPath(), Files.readString(t.getOutputFile().getAsFile().get().toPath(), UTF_8).replace("\"name\": \"" + publication.getArtifactId() + "-" + publication.getVersion() + "\"", "\"name\": \"" + one(publication.getArtifacts()).getFile().getName() + "\"").getBytes(UTF_8));
                                } catch (
                                        IOException e) {
                                    throw new UncheckedIOException(e);
                                }
                            }

                            private <T> T one(Iterable<T> items) {
                                final Iterator<T> iter = items.iterator();
                                assert iter.hasNext();
                                T result = iter.next();
                                assert !iter.hasNext();
                                return result;
                            }
                        }));
                    }
                }

                @SuppressWarnings("unchecked")
                public <T extends Task> Action<Task> forTaskType(Action<? super T> action) {
                    // !!! Must use anonymous class !!!
                    return new Action<>() {
                        @Override
                        public void execute(Task task) {
                            action.execute((T) task);
                        }
                    };
                }
            });
        };
    }

    private static Action<CppTestExecutable> registerTestExecutablePublication(Project project, CppTestSuite unitTest) {
        return new Action<>() {
            @Override
            public void execute(CppTestExecutable binary) {
                final SoftwareComponent testComponent = newSoftwareComponent(qualifyingName(binary), component -> {
                    // We expect the testExecutableRuntimeElements to already exists
                    final Configuration runtimeElements = project.getConfigurations().getByName(qualifyingName(binary) + "RuntimeElements");
                    component.addVariantsFromConfiguration(runtimeElements, it -> { /* nothing to do */ });
                });

                project.getPluginManager().withPlugin("maven-publish", __ -> {
                    final PublishingExtension publishing = project.getExtensions().getByType(PublishingExtension.class);
                    publishing.publications(publications -> {
                        final NamedDomainObjectProvider<MavenPublication> binaryPublication = publications.register(qualifyingName(binary), MavenPublication.class);
                        binaryPublication.configure(publishWithOriginalFileName(project));
                        binaryPublication.configure(publication -> {
                            publication.from(testComponent); // Use SoftwareComponent to benefit from Gradle's automation

                            // Will override if there is only one binary later
                            publication.setArtifactId(project.getName() + capitalize(unitTest.getName()) + "_" + variantId(binary.getTargetMachine()));
                        });
                    });
                });
            }

            private SoftwareComponent newSoftwareComponent(String name, Action<? super AdhocComponentWithVariants> action) {
                AdhocComponentWithVariants component = project.getObjects().newInstance(SoftwareComponentFactoryProvider.class).get().adhoc(name);
                action.execute(component);
                project.getComponents().add(component);
                return component;
            }
        };
    }

    public void apply(Project project) {
        project.getComponents().withType(CppTestSuite.class).all(unitTest -> {
            // We register the testExecutableRuntimeElements separately from usage because we could separate them both, in theory.
            unitTest.getBinaries().configureEach(CppTestExecutable.class,
                    registerTestExecutableRuntimeElements(project, unitTest));

            unitTest.getBinaries().configureEach(CppTestExecutable.class, registerTestExecutablePublication(project, unitTest));

            project.afterEvaluate(ignored -> {
                project.getPluginManager().withPlugin("maven-publish", __ -> {
                    final TaskProvider<GenerateComponentGradleModuleMetadata> generateTask = project.getTasks().register(String.format("generate%sGradleModuleMetadata", capitalize(unitTest.getName())), GenerateComponentGradleModuleMetadata.class, task -> {
                        task.getModuleFile().convention(project.getLayout().getBuildDirectory().file(unitTest.getName() + ".module"));
                        task.getStatus().set(project.provider(() -> unpack(project.getStatus())).map(Object::toString));
                    });


                    PublishingExtension publishing = project.getExtensions().getByType(PublishingExtension.class);
                    publishing.publications(publications -> {
                        // When multiple unit tests binary, prepare an aggregate publication
                        if (publications.findByName(unitTest.getName()) == null) {
                            for (TargetMachine targetMachine : unitTest.getTargetMachines().get()) {
                                generateTask.configure(task -> {
                                    task.getVariants().create(unitTest.getName() + capitalize(targetMachine.getOperatingSystemFamily().getName()) + capitalize(targetMachine.getArchitecture().getName()) + "RuntimeElements", variant -> {
                                        variant.attribute(Usage.USAGE_ATTRIBUTE, project.getObjects().named(Usage.class, Usage.NATIVE_RUNTIME));
                                        variant.attribute(MachineArchitecture.ARCHITECTURE_ATTRIBUTE, targetMachine.getArchitecture());
                                        variant.attribute(OperatingSystemFamily.OPERATING_SYSTEM_ATTRIBUTE, targetMachine.getOperatingSystemFamily());
                                        variant.attribute(CppBinary.OPTIMIZED_ATTRIBUTE, false);
                                        variant.attribute(CppBinary.DEBUGGABLE_ATTRIBUTE, true);
                                        variant.attribute(TEST_SUITE_NAME_ATTRIBUTE, unitTest.getName());
                                        variant.attribute(TEST_SUITE_TYPE_ATTRIBUTE, UNIT_TEST);
                                        variant.getArtifactId().set(project.getName() + capitalize(unitTest.getName()) + "_" + variantId(targetMachine));
                                    });
                                });
                            }

                            publications.create(unitTest.getName(), MavenPublication.class, publication -> {
                                publication.artifact(generateTask);
                                publication.pom(new Action<>() {
                                    @Override
                                    public void execute(MavenPom pom) {
                                        pom.setPackaging("pom");
                                        pom.withXml(withGradleModuleMetadataRedirectComment()); // force module redirection comment
                                    }

                                    private Action<XmlProvider> withGradleModuleMetadataRedirectComment() {
                                        return xml -> {
                                                final int idx = xml.asString().indexOf("  <modelVersion>");
                                                xml.asString().insert(idx, String.join("\n",
                                                        "<!-- This module was also published with a richer model, Gradle metadata,  -->",
                                                        "<!-- which should be used instead. Do not delete the following line which  -->",
                                                        "<!-- is to indicate to Gradle or any Gradle module metadata file consumer  -->",
                                                        "<!-- that they should prefer consuming it instead. -->",
                                                        "<!-- do_not_remove: published-with-gradle-metadata -->"));
		                                };
                                    }
                                });
                                generateTask.configure(task -> {
                                    task.getGroupId().set(project.provider(publication::getGroupId));
                                    task.getArtifactId().set(project.provider(publication::getArtifactId));
                                    task.getVersion().set(project.provider(publication::getVersion));
                                    task.getModuleFile().set(project.getLayout().getBuildDirectory().file(task.getArtifactId().map(it -> it + ".module")));
                                });
                            });
                        }

                        // Override artifactId for both the single variant or multi-variant
                        publications.named(unitTest.getName(), MavenPublication.class, publication -> {
                            publication.setArtifactId(project.getName() + capitalize(unitTest.getName()));
                        });
                    });
                });
            });
        });
    }

    private static String variantId(TargetMachine targetMachine) {
        return targetMachine.getOperatingSystemFamily().getName() + "_" + targetMachine.getArchitecture().getName();
    }

    //region Names
    private static String qualifyingName(CppBinary binary) {
        String result = binary.getName();
        if (result.startsWith("main")) {
            result = result.substring("main".length());
        } else if (result.endsWith("Executable")) {
            result = result.substring(0, result.length() - "Executable".length());
        }
        return uncapitalize(result);
    }
    //endregion

    //region StringUtils
    private static String uncapitalize(String s) {
        return Character.toLowerCase(s.charAt(0)) + s.substring(1);
    }

    private static String capitalize(String s) {
        return Character.toUpperCase(s.charAt(0)) + s.substring(1);
    }
    //endregion

    //region Provider class to avoid reaching into `ServiceRegistry` from `ProjectInternal#getServices()`.
    static abstract class SoftwareComponentFactoryProvider {
        private final SoftwareComponentFactory theService;

        @Inject
        public SoftwareComponentFactoryProvider(SoftwareComponentFactory theService) {
            this.theService = theService;
        }

        public SoftwareComponentFactory get() {
            return theService;
        }
    }
    //endregion
}
